//@version=6
indicator(title="MA TPI", shorttitle="RSI", format=format.price, precision=2, timeframe="", timeframe_gaps=true)


// ALMA (Arnaud Legoux)
alma()=>
    TT_OFFSET = "Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0)."
    TT_SIGMA  = "This element is a standard deviation that is applied to the combo line in order for it to appear more sharp."
    source = close
    lengthInput =  input.int(9,      "Length", minval  = 1)
    offsetInput =  input.float(0.85, "Offset", step = 0.01, tooltip = TT_OFFSET)
    sigmaInput  =  input.float(6,    "Sigma",               tooltip = TT_SIGMA)
    alma = ta.alma(source, lengthInput, offsetInput, sigmaInput), "ALMA"
    alma

// ARSI (Adaptive RSI)
arsi()=>
    length = input(title = 'Length', defval = 14)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)

    alpha = 2 * math.abs(ta.rsi(src, length) / 100 - 0.5)

    arsi = 0.0
    arsi := alpha * src + (1 - alpha) * nz(arsi[1])
    arsi


// DEMA (Double Exponential)
dema()=>
    length = input.int(9, minval=1)
    src = input(close, title="Source")
    e1 = ta.ema(src, length)
    e2 = ta.ema(e1, length)
    dema = 2 * e1 - e2
    dema

// EMA (Exponential)
ema()=>
    len = input.int(9, minval=1, title="Length")
    src = input(close, title="Source")
    offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window)
    ema = ta.ema(src, len)
    ema

// FRAMA (Fractal Adaptive)
frama()=>
    length = input(title = 'Length', defval = 14)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)

    length2 = math.floor(length / 2)

    hh2 = ta.highest(length2)
    ll2 = ta.lowest(length2)

    N1 = (hh2 - ll2) / length2

    N2 = (hh2[length2] - ll2[length2]) / length2

    N3 = (ta.highest(length) - ta.lowest(length)) / length

    D = (math.log(N1 + N2) - math.log(N3)) / math.log(2)

    factor = math.exp(-4.6 * (D - 1))

    frama = 0.0
    frama := factor * src + (1 - factor) * nz(frama[1])
    frama

// HMA (Hull)
hma()=>
    length = input.int(9, "Length", minval = 2)
    src    = input(close, "Source")
    hullma = ta.wma(2*ta.wma(src, length/2)-ta.wma(src, length), math.floor(math.sqrt(length)))
    hullma

// LSQMA (Least Squares)
lsma()=>
    length = input(title="Length", defval=25)
    offset = input(title="Offset", defval=0)
    src = input(close, title="Source")
    lsma = ta.linreg(src, length, offset)

// LWMA (Linear Weighted)

//{ LWMA Custom Weighted Function
lwma() =>
    src = input(close, title = 'LWMA Source:')
    period = input.int(10, title = 'LWMA Lookback Period:', minval = 1, step = 1)
    weight = input.int(6, title = 'LWMA Weight:', minval = 1, step = 1)
    colorChange = input(true, title = 'Directional color change?')
    price = src
    sub = weight / period - 1
    float p = na
    float d = na
    float sum = 0
    float divider = 0
    for i = 0 to period - 1 by 1
        p := price[i] * (weight - i - sub)
        d := weight - i - sub
        sum := sum + p
        divider := divider + d
        divider
    lwma = sum / divider
    lwma



// MD (McGinley Dynamic)
md()=>
    length = input.int(14, minval=1)
    source = close
    mg = 0.0
    mg := na(mg[1]) ? ta.ema(source, length) : mg[1] + (source - mg[1]) / (length * math.pow(source/mg[1], 4))
    mg

// REMA (Regularized Exponential)
rema()=>
    length = input(title = 'Length', defval = 14)
    lambda = input.float(title = 'Regularization Constant', minval = 0, defval = 0.5)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)

    alpha = 2 / (length + 1)

    rema = 0.0
    rema := (nz(rema[1]) + alpha * (src - nz(rema[1])) + lambda * (2 * nz(rema[1]) - nz(rema[2]))) / (lambda + 1)
    rema


// RMA (EMA with alpha = length - 1)
rma()=>
    period = input.int(9, minval = 1, title = 'RMA Period')
    source = input(close, title = 'RMA Source')
    rma = ta.rma(source, period)

// SMA (Simple)
sma()=>
    len = input.int(9, minval=1, title="Length")
    src = input(close, title="Source")
    offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window)
    sma = ta.sma(src, len)
    sma

// SMMA (Smoothed)
smma()=>
    len = input.int(7, minval=1, title="Length")
    src = input(close, title="Source")
    smma = 0.0
    smma := na(smma[1]) ? ta.sma(src, len) : (smma[1] * (len - 1) + src) / len
    smma

// TEMA (Triple Exponential)
tema()=>
    length = input.int(9, minval=1)
    ema1 = ta.ema(close, length)
    ema2 = ta.ema(ema1, length)
    ema3 = ta.ema(ema2, length)
    tema = 3 * (ema1 - ema2) + ema3
    tema

// TMA (Triangular)
tma()=>
    length = input.int(title = 'Length', minval = 1, defval = 20)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)
    tma = ta.sma(ta.sma(src, math.ceil(length / 2)), math.floor(length / 2) + 1)
    tma

// T3
gd(src, length, factor) =>
    ta.ema(src, length) * (1 + factor) - ta.ema(ta.ema(src, length), length) * factor
tz()=>
    length = input(title = 'Length', defval = 5)
    factor = input.float(title = 'Factor', minval = 0, maxval = 1, defval = 0.7)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)
    t3 = gd(gd(gd(src, length,factor), length,factor), length,factor)
    t3

// VIDYA (Variable Index Dynamic)
// Chande Momentum Oscillator
getCMO(src, length) =>
    mom = ta.change(src)
    upSum = math.sum(math.max(mom, 0), length)
    downSum = math.sum(-math.min(mom, 0), length)
    out = (upSum - downSum) / (upSum + downSum)
    out
VIDYA()=>
    length = input(title = 'Length', defval = 14)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)
    cmo = math.abs(getCMO(src, length))
    alpha = 2 / (length + 1)
    vidya = 0.0
    vidya := src * alpha * cmo + nz(vidya[1]) * (1 - alpha * cmo)
    vidya

// VWMA (Volume Weighted)
vwma()=>
    len = input.int(20, "Length", minval=1)
    src = input(close, "Source")
    ma = ta.vwma(src, len)
    ma

// WMA (Weighted)
wma()=>
    len = input.int(9, minval=1, title="Length")
    src = input(close, title="Source")
    offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window)
    out = ta.wma(src, len)
    out

// WWMA (Welles Wilderâ€™s Moving Average, EMA with alpha = 1 / length)
wwma()=>
    Period = input.int(14, title = 'Period', minval = 1)
    src = input(close, title = 'Source')
    alpha = 1 / Period
    WM = 0.0
    WM := alpha * src + (1 - alpha) * nz(WM[1])
    WM

// ZLEMA (Zero Lag Exponential)
zlema()=>
    length = input(title = 'Length', defval = 14)
    highlightMovements = input(title = 'Highlight Movements ?', defval = true)
    src = input(title = 'Source', defval = close)

    lag = math.floor((length - 1) / 2)

    zlema = ta.ema(src + src - src[lag], length)
    zlema
